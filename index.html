<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Fast QR + Barcode Scanner</title>
  <meta name="theme-color" content="#0ea5e9" />
  <style>
    :root {
      --bg: #0b1220;
      --panel: #121a2b;
      --muted: #8aa0bf;
      --text: #e6eefc;
      --accent: #0ea5e9;
      --accent-2: #22d3ee;
      --danger: #ef4444;
      --ok: #22c55e;
      --ring: 0 0 0 3px rgba(14,165,233,.25);
    }
    * { box-sizing: border-box; }
    html, body { height: 100%; }
    body {
      margin: 0; font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans,
      Helvetica Neue, Arial, "Apple Color Emoji", "Segoe UI Emoji";
      color: var(--text); background: linear-gradient(180deg, #0b1220, #0c1526 40%, #091020);
    }
    .container { max-width: 980px; margin: 0 auto; padding: 20px; }
    header { display:flex; gap:16px; align-items:center; justify-content:space-between; margin-bottom: 14px; }
    h1 { font-size: clamp(1.15rem, 2.5vw, 1.5rem); margin: 0; font-weight: 700; letter-spacing: .2px; }
    .badge { font-size: .72rem; color:#053a49; background: linear-gradient(135deg, #22d3ee, #0ea5e9); padding: 6px 10px; border-radius: 999px; font-weight: 700; }

    .panel { background: radial-gradient(1200px 500px at 0% -20%, rgba(34,211,238,0.08), transparent 60%),
                           radial-gradient(1000px 500px at 100% 120%, rgba(14,165,233,0.08), transparent 55%),
                           var(--panel);
             border:1px solid rgba(255,255,255,.06); border-radius: 16px; box-shadow: 0 10px 40px rgba(0,0,0,.35);
             overflow: hidden; }

    .controls { display: grid; grid-template-columns: 1fr; gap: 10px; padding: 14px; }
    @media (min-width: 720px){ .controls { grid-template-columns: 1fr 1fr 1fr 1fr auto; } }

    label { font-size: .82rem; color: var(--muted); }
    select, button, input[type="file"] {
      width: 100%; background: #0f1728; color: var(--text); border:1px solid rgba(255,255,255,.12);
      padding: 10px 12px; border-radius: 10px; outline: none; transition: box-shadow .15s ease, border-color .15s ease;
    }
    select:focus, button:focus, input[type="file"]:focus { box-shadow: var(--ring); border-color: var(--accent); }

    .btn { cursor: pointer; display:inline-flex; align-items:center; justify-content:center; gap:8px; font-weight: 700; }
    .btn-primary { background: linear-gradient(135deg, var(--accent), var(--accent-2)); border: none; color: #05222d; }
    .btn-ghost { background: #0f1728; }
    .btn-danger { background: #2b1111; border-color: #3a1515; }
    .btn[disabled] { opacity: .5; cursor: not-allowed; }

    .video-wrap { position: relative; background: #0b1220; aspect-ratio: 16/9; min-height: 240px; }
    video { width: 100%; height: 100%; object-fit: cover; background: #000; border-bottom: 1px solid rgba(255,255,255,.08); }

    /* overlay */
    .overlay { position:absolute; inset:0; pointer-events:none; display:grid; place-items:center; }
    .reticle { width: clamp(180px, 40vmin, 360px); height: clamp(180px, 40vmin, 360px); border-radius: 14px;
               outline: 3px dashed rgba(34,211,238,.55); outline-offset:-6px; box-shadow: inset 0 0 0 2px rgba(14,165,233,.25);
               position: relative; }
    .reticle::before, .reticle::after { content:""; position:absolute; border:2px solid rgba(14,165,233,.65); width:22%; height:22%; }
    .reticle::before { top:-2px; left:-2px; border-right:none; border-bottom:none; border-radius: 12px 0 0 0; }
    .reticle::after  { bottom:-2px; right:-2px; border-left:none; border-top:none; border-radius: 0 0 12px 0; }

    .meter { position:absolute; left:12px; bottom:12px; right:12px; display:flex; align-items:center; gap:8px; }
    .meter progress { width: 100%; height: 8px; accent-color: var(--accent); }

    .flex { display:flex; gap:8px; align-items:center; }
    .grow { flex: 1 1 auto; }

    .row { display:grid; grid-template-columns: 1fr; gap: 8px; padding: 12px 14px; align-items:center; }
    @media (min-width: 560px){ .row { grid-template-columns: 1fr auto auto; } }

    .result { display:flex; gap:10px; align-items:center; justify-content:space-between; padding: 12px 14px; border-top:1px solid rgba(255,255,255,.08); }
    .code { font-family: ui-monospace, Menlo, Consolas, "SF Mono", monospace; background: #0f1728; padding: 6px 10px; border-radius: 8px; border:1px solid rgba(255,255,255,.08); word-break: break-all; }
    .stamp { font-size:.75rem; color: var(--muted); }

    .hint { color: var(--muted); font-size: .86rem; padding: 8px 2px 14px; }
    .error { color: #fecaca; background: #2b1111; border:1px solid #3a1515; padding: 10px 12px; border-radius: 10px; }
    footer { opacity:.75; font-size:.8rem; margin-top: 14px; }
  </style>
</head>
<body>
  <div class="container">
    <header>
      <h1>Fast QR + Barcode Scanner</h1>
      <span class="badge">Multi‚Äëformat ‚Ä¢ Mobile‚Äëready</span>
    </header>

    <section class="panel">
      <div class="controls">
        <div>
          <label for="cameraSel">Camera</label>
          <select id="cameraSel" title="Choose camera"></select>
        </div>
        <div>
          <label for="resolutionSel">Resolution</label>
          <select id="resolutionSel" title="Choose resolution">
            <option value="auto" selected>Auto</option>
            <option value="hd">HD (1280√ó720)</option>
            <option value="fhd">FHD (1920√ó1080)</option>
          </select>
        </div>
        <div>
          <label for="modeSel">Mode</label>
          <select id="modeSel" title="Scan mode">
            <option value="continuous" selected>Continuous</option>
            <option value="single">Single shot</option>
          </select>
        </div>
        <div class="flex">
          <button id="startBtn" class="btn btn-primary grow" title="Start scanning">‚ñ∂ Start</button>
          <button id="stopBtn" class="btn btn-ghost" disabled title="Stop scanning">‚èπ Stop</button>
        </div>
        <div class="flex">
          <button id="torchBtn" class="btn btn-ghost grow" disabled title="Toggle torch">üí° Torch</button>
          <input id="filePicker" type="file" accept="image/*" />
        </div>
      </div>

      <div class="video-wrap">
        <video id="video" playsinline muted></video>
        <div class="overlay">
          <div class="reticle" aria-hidden="true"></div>
          <div class="meter">
            <span class="stamp" id="fmt">‚Äî</span>
            <progress id="quality" max="100" value="0"></progress>
          </div>
        </div>
      </div>

      <div class="row">
        <div class="grow hint">Tip: For best speed, use good lighting and the rear camera. Torch + zoom help for tiny codes.</div>
        <div class="flex">
          <label class="stamp" for="zoom">Zoom</label>
          <input id="zoom" type="range" min="0" max="100" value="0" disabled />
        </div>
      </div>

      <div id="errorBox" class="row" hidden>
        <div class="error" id="errorText">Camera error</div>
      </div>

      <div class="result">
        <div class="grow">
          <div class="code" id="lastCode">‚Äî</div>
          <div class="stamp" id="lastTime">Ready</div>
        </div>
        <div class="flex">
          <button id="copyBtn" class="btn btn-ghost">Copy</button>
          <button id="clearBtn" class="btn btn-danger">Clear</button>
        </div>
      </div>
    </section>

    <footer>
      Works best over HTTPS or localhost. No data leaves your device. ZXing multi‚Äëformat decoding (QR + EAN/UPC/Code128/ITF/Codabar).
    </footer>
  </div>

  <audio id="beep" preload="auto">
    <source src="data:audio/mp3;base64,//uQZAAAAAAAAAAAAAAAAAAAA..." type="audio/mpeg">
  </audio>

  <script type="module">
    // Fast, cross‚Äëplatform QR + 1D barcode scanning using ZXing (zxing-js)
    import {
      BrowserMultiFormatReader,
      DecodeHintType,
      BarcodeFormat
    } from 'https://cdn.jsdelivr.net/npm/@zxing/library@0.20.0/esm/index.js';

    // DOM refs
    const video = document.getElementById('video');
    const startBtn = document.getElementById('startBtn');
    const stopBtn = document.getElementById('stopBtn');
    const cameraSel = document.getElementById('cameraSel');
    const resSel = document.getElementById('resolutionSel');
    const modeSel = document.getElementById('modeSel');
    const torchBtn = document.getElementById('torchBtn');
    const zoomSlider = document.getElementById('zoom');
    const filePicker = document.getElementById('filePicker');

    const lastCodeEl = document.getElementById('lastCode');
    const lastTimeEl = document.getElementById('lastTime');
    const fmtEl = document.getElementById('fmt');
    const qualityEl = document.getElementById('quality');

    const errorBox = document.getElementById('errorBox');
    const errorText = document.getElementById('errorText');

    const copyBtn = document.getElementById('copyBtn');
    const clearBtn = document.getElementById('clearBtn');
    const beep = document.getElementById('beep');

    // ZXing setup: accept QR + common 1D formats for speed
    const formats = [
      BarcodeFormat.QR_CODE,
      BarcodeFormat.EAN_13, BarcodeFormat.EAN_8,
      BarcodeFormat.UPC_A, BarcodeFormat.UPC_E,
      BarcodeFormat.CODE_128, BarcodeFormat.CODE_39,
      BarcodeFormat.ITF, BarcodeFormat.CODABAR
    ];
    const hints = new Map([
      [DecodeHintType.POSSIBLE_FORMATS, formats],
      [DecodeHintType.TRY_HARDER, true]
    ]);

    const reader = new BrowserMultiFormatReader(hints);

    let currentTrack = null; // MediaStreamTrack for torch/zoom
    let running = false;
    let lastText = '';
    let lastTime = 0;
    const DUP_MS = 1200; // throttle duplicate detections

    // --- Camera enumeration & population ---
    async function listCameras() {
      const devices = await navigator.mediaDevices.enumerateDevices();
      const cams = devices.filter(d => d.kind === 'videoinput');
      cameraSel.innerHTML = '';
      cams.forEach((cam, idx) => {
        const opt = document.createElement('option');
        opt.value = cam.deviceId || '';
        opt.textContent = cam.label || `Camera ${idx+1}`;
        cameraSel.appendChild(opt);
      });
      if (cams.length === 0) {
        cameraSel.innerHTML = '<option>No camera found</option>';
      }
    }

    function constraintsForSelected() {
      const res = resSel.value;
      let width, height;
      if (res === 'hd') { width = {ideal:1280}; height = {ideal:720}; }
      else if (res === 'fhd') { width = {ideal:1920}; height = {ideal:1080}; }
      else { width = {ideal:1280}; height = {ideal:720}; } // auto hint

      const deviceId = cameraSel.value;
      const base = {
        video: {
          width, height,
          facingMode: deviceId ? undefined : { ideal: 'environment' },
          deviceId: deviceId ? { exact: deviceId } : undefined,
          focusMode: 'continuous' // hint for some UAs
        },
        audio: false
      };
      return base;
    }

    function setError(msg) {
      errorText.textContent = msg;
      errorBox.hidden = false;
    }
    function clearError() { errorBox.hidden = true; }

    async function start() {
      clearError();
      if (!('mediaDevices' in navigator)) { setError('Camera API not supported in this browser.'); return; }
      startBtn.disabled = true; stopBtn.disabled = false;

      const cons = constraintsForSelected();
      running = true;

      try {
        await reader.decodeFromConstraints(cons, video, onResult);
        // Note: decodeFromConstraints returns immediately; reader runs continuously until reset()
      } catch (e) {
        setError(e?.message || String(e));
        startBtn.disabled = false; stopBtn.disabled = true; running = false;
        return;
      }

      // Grab track for torch/zoom
      const stream = video.srcObject;
      currentTrack = stream && stream.getVideoTracks ? stream.getVideoTracks()[0] : null;
      setupCapabilities();
    }

    function stop() {
      running = false;
      reader.reset();
      if (video.srcObject) {
        video.srcObject.getTracks().forEach(t => t.stop());
        video.srcObject = null;
      }
      startBtn.disabled = false; stopBtn.disabled = true; torchBtn.disabled = true; zoomSlider.disabled = true;
      fmtEl.textContent = '‚Äî'; qualityEl.value = 0;
    }

    function onResult(result, err) {
      if (result) {
        const text = result.getText();
        const now = Date.now();
        if (text === lastText && (now - lastTime) < DUP_MS) {
          // Duplicate within window: ignore but still update quality bar if available
          updateMeta(result);
          return;
        }
        lastText = text; lastTime = now;
        updateMeta(result);
        onDecoded(text, result.getBarcodeFormat());
      }
      // ZXing fires NotFoundException frequently when no code in frame; ignore 'err'
    }

    function updateMeta(result){
      fmtEl.textContent = String(result.getBarcodeFormat());
      // Fake a quality meter using number of points if available (ZXing doesn't expose confidence)
      try {
        const pts = result.getResultPoints?.() || [];
        const score = Math.min(100, 30 + pts.length * 17); // heuristic
        qualityEl.value = score;
      } catch { /* noop */ }
    }

    // What to do when we decode a value
    function onDecoded(text, format){
      lastCodeEl.textContent = text;
      lastTimeEl.textContent = new Date().toLocaleString();
      try { beep.currentTime = 0; beep.play().catch(() => {}); } catch {}
      if (navigator.vibrate) navigator.vibrate(30);

      if (modeSel.value === 'single') {
        // Pause after one successful read, but keep the frame
        stop();
      }
    }

    function setupCapabilities(){
      if (!currentTrack || !currentTrack.getCapabilities) { torchBtn.disabled = true; zoomSlider.disabled = true; return; }
      const caps = currentTrack.getCapabilities();

      // Torch
      if ('torch' in caps) {
        torchBtn.disabled = false;
      } else { torchBtn.disabled = true; }

      // Zoom
      if (caps.zoom) {
        zoomSlider.disabled = false;
        // Set slider to current zoom range [min..max]
        const settings = currentTrack.getSettings();
        const min = caps.zoom.min ?? 0; const max = caps.zoom.max ?? 100;
        const current = settings.zoom ?? min;
        // map [min..max] -> [0..100]
        const pct = Math.round(((current - min) / (max - min)) * 100);
        zoomSlider.value = isFinite(pct) ? pct : 0;
        zoomSlider.oninput = () => {
          const val = Number(zoomSlider.value);
          const target = min + (max - min) * (val/100);
          currentTrack.applyConstraints({ advanced: [{ zoom: target }] }).catch(() => {});
        };
      } else {
        zoomSlider.disabled = true;
      }
    }

    async function toggleTorch(){
      if (!currentTrack || !currentTrack.getCapabilities) return;
      const caps = currentTrack.getCapabilities();
      if (!('torch' in caps)) return;
      const settings = currentTrack.getSettings();
      const on = !settings.torch;
      try {
        await currentTrack.applyConstraints({ advanced: [{ torch: on }] });
      } catch {}
    }

    // --- Image file decoding fallback ---
    filePicker.addEventListener('change', async (e) => {
      const file = e.target.files?.[0];
      if (!file) return;
      try {
        const imgUrl = URL.createObjectURL(file);
        const result = await reader.decodeFromImageUrl(imgUrl);
        URL.revokeObjectURL(imgUrl);
        if (result) onDecoded(result.getText(), result.getBarcodeFormat());
      } catch (err) {
        setError('Could not decode from image. Try a clearer photo.');
        setTimeout(clearError, 2500);
      }
    });

    // --- UI events ---
    startBtn.addEventListener('click', start);
    stopBtn.addEventListener('click', stop);
    torchBtn.addEventListener('click', toggleTorch);
    cameraSel.addEventListener('change', () => { if (running) { stop(); start(); } });
    resSel.addEventListener('change',    () => { if (running) { stop(); start(); } });

    copyBtn.addEventListener('click', async () => {
      const txt = lastCodeEl.textContent?.trim();
      if (!txt || txt === '‚Äî') return;
      try { await navigator.clipboard.writeText(txt); lastTimeEl.textContent = 'Copied!'; } catch {}
    });
    clearBtn.addEventListener('click', () => { lastCodeEl.textContent = '‚Äî'; qualityEl.value = 0; fmtEl.textContent = '‚Äî'; lastTimeEl.textContent = 'Ready'; });

    // Keyboard shortcuts: Space = start/stop
    window.addEventListener('keydown', (e) => {
      if (e.code === 'Space') {
        e.preventDefault();
        if (!running) start(); else stop();
      }
    });

    // Populate cameras on load + when devices change
    window.addEventListener('load', async () => {
      try { await listCameras(); } catch {}
      navigator.mediaDevices?.addEventListener?.('devicechange', listCameras);
    });
  </script>
</body>
</html>